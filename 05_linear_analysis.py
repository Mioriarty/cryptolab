from typing import Callable
from numpy import log2, uint8, uint16
import random


def generateSPN(sBox : list[list[uint8]], pBox : list[list[uint8]], numRounds : int) -> Callable[[uint16, list[uint16]], uint16]:
    """
    Generates an enciphering method for a arbetrary substitution permutation network (spn). 

    It will encipher uint16 values.

    Args:
        sBox (list[uint8]): S-boxes per round. If sBox[r][a] = b that means that in the r-th round a 4-bit chunk of value a will be replaced by a 4-bit chunk of value b. 
        pBox (list[uint8]): P-boxes per round. If pBox[r][a] = b that means that in the r-th round a 4-bit chunk at position a will be moved to position b.
        numRounds (int): How many rounds should be done. The sBox and pBox should have at liest this many elements.

    Returns:
        Callable[[uint16, list[uint16]], uint16]: The created enciphering method for the spn.
    """


    def encipher(plaintext : uint16, keys : list[uint16]) -> uint16:
        cryptotext = plaintext

        for round in range(numRounds):
            # key addition
            cryptotext = cryptotext ^ keys[round]

            # substitution
            temp = uint16(0)
            for chunk in range(3, -1, -1):
                chunkValue = (cryptotext >> (chunk * 4)) & 0b1111
                temp <<= 4
                temp ^= sBox[round][chunkValue]
            cryptotext = temp

            # permutation, not in the last round
            if round < numRounds-1:
                temp = uint16(0)
                for bit in range(16):
                    temp ^= ((cryptotext >> bit) & 1) << pBox[round][bit]
                cryptotext = temp
        

        cryptotext = cryptotext ^ keys[numRounds]
        
        return cryptotext
    
    return encipher


def bindKeysToSPN(spn : Callable[[uint16, list[uint16]], uint16], keys : list[uint16]) -> Callable[[uint16], uint16]:
    """
    Binds round keys to the spn function call.

    Args:
        spn (Callable[[uint16, list[uint16]], uint16]): Origanal spn (enciphering method)
        keys (list[uint16]): All round keys. Should have at least one more round key than the spn's number of round.

    Returns:
        Callable[[uint16], uint16]: The bound enciphering method.
    """
    return lambda plaintext : spn(plaintext, keys)

def countSetBits(n : uint16) -> int:
    """
    Counts the amount of 1-bits in a number.

    Args:
        n (uint16): The number the 1-bits shell be counted.

    Returns:
        int: The amount of 1-bits.
    """
    if n == 0:
        return 0
    else:
        return (n & 1) + countSetBits(n >> 1)

def doLinearAnalysis(plainCryptoPairs : list[tuple[uint16]], sBox : list[uint16], approximationInputs : uint16, approximationLastRound : uint16) -> uint16:
    """
    Performs linear analysis on plaintext-ciphertext-pairs generated by an spn. It will returned guessed parts of the last round key.

    At the heart of the analysis lies the linear approximation.
    eg X_5 + X_7 + X_8 + U_6 + U_8 + U_14 + U_16 = 0. Here X stands vor the input vector and U stands for the output of the second to last key addition.
    Remember: In a spn there is still 1 substitution and 1 key addition togo. 

    Args:
        plainCryptoPairs (list[tuple[uint16]]): All available plaintext ciphertext pairs. (8000 or more)
        sBox (list[uint16]): The sBox used in the spn at the last round.
        approximationInputs (uint16): Input bits that are included in the linear approximation. For the example above that would be 0b0000101100000000
        approximationLastRound (uint16): Bits after the second to last key addition that are included in the lienare approximation. For the example above that would be 0b0000010100000101

    Returns:
        uint16: Guessed parts of the last round key.
    """
    
    # calculate inverse sBox
    sBoxInv = [0] * 16
    for index, val in enumerate(sBox):
        sBoxInv[val] = index
    

    # start with actual linear analysis
    keyBiases = {}

    # which chunks do we have to include in the key search
    # meaning which chunks are included in the output approximation
    includedChunks = [i for i in range(4) if ((approximationLastRound >> i*4) & 0b1111) != 0]

    for smushedKey in range(1 << (len(includedChunks) * 4)):
        # convert smushed key into the actual key
        # eg. if the smushed key is 10101010 and the 2nd and 4th chunk are included in the search we will get the key: 1010 0000 1010 0000
        key = uint16(0)
        for chunkIndex, chunk in enumerate(includedChunks):
            key ^= (smushedKey >> (chunkIndex * 4) & 0b1111) << (chunk * 4)
        
        print("{:16b}".format(key))
        
        # try out every plaintext ciphertext pair
        succeededAttemps = 0
        for plaintext, cryptotext in plainCryptoPairs:
            # backwards key addition
            guessed = cryptotext ^ key

            # backward substitution
            guessedBeforeSub = uint16(0)
            for chunk in range(3, -1, -1):
                chunkValue = (guessed >> (chunk * 4)) & 0b1111
                guessedBeforeSub <<= 4
                guessedBeforeSub ^= sBoxInv[chunkValue]
            
            # check linear approximation
            filteredPlaintext = approximationInputs & plaintext
            filteredBeforeSub = approximationLastRound & guessedBeforeSub

            if (countSetBits(filteredPlaintext) + countSetBits(filteredBeforeSub)) % 2 == 0:
                succeededAttemps += 1
        
        # calculate bias
        bias = (succeededAttemps / len(plainCryptoPairs)) - 1/2
        keyBiases[key] = bias
    
    # extract maximum bias
    bestKey = max(keyBiases, key = lambda e : abs(keyBiases[e]))
    print(f"Best bias: {keyBiases[key]}")
    return bestKey

if __name__ == "__main__":
    SBOX = [ 0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8, 0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7 ]
    PBOX = [ 0x0, 0x4, 0x8, 0xC, 0x1, 0x5, 0x9, 0xD, 0x2, 0x6, 0xA, 0xE, 0x3, 0x7, 0xB, 0xF ]
    # KEY  = 0x1Ab2
    KEY  = 0x5F21

    spn = bindKeysToSPN(generateSPN([SBOX]*4, [PBOX]*4, 4), [KEY]*5)


    # generate plaintext cryptotext pairs
    plainCryptoPairs = []
    for _ in range(8000):
        plaintext = uint16(int(random.uniform(0, 2**16-1)))
        plainCryptoPairs.append((plaintext, spn(plaintext)))


    guessedKey = doLinearAnalysis(plainCryptoPairs, SBOX, 0b0000101100000000, 0b0000010100000101)
    print("\nGuessed Key:")
    print("{:16b}".format(guessedKey))
    print("Actual Key:")
    print("{:16b}".format(KEY))
